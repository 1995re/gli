GLI Manual
==========
Christophe Riccio <gli@g-truc.net>
:Author Initials: CR
:toc:
:icons:
:numbered:
:website: http://gli.g-truc.net


Introduction
------------
OpenGL Image (GLI) is a header only C++ image library for graphics software.

This library works perfectly with OpenGL but it also ensures interoperability with other third party libraries and SDK. It is a good candidate for software rendering (raytracing / rasterisation), image processing, physic simulations and any development context that requires a simple and convenient mathematics library.

GLI is written in C++ 11. It is a platform independent library with no dependence and it supports the following compilers:

- https://developer.apple.com/library/mac/documentation/CompilerTools/Conceptual/LLVMCompilerOverview/index.html[Apple Clang 4.0] and higher
- http://gcc.gnu.org/[GCC 4.6] and higher
- https://software.intel.com/en-us/intel-compilers[Intel C++ Composer XE 2013] and higher
- http://llvm.org/[LLVM 3.2] and higher
- http://www.visualstudio.com[Visual Studio 2012] and higher
- Any conform C++11 compiler

For more information about GLI, please have a look at http://gli.g-truc.net/0.6.1/api/index.html[the API reference documentation].

The source code and the documentation, including this manual, are licensed under the http://glm.g-truc.net/copying.txt[Happy Bunny License (Modified MIT) or the MIT License].

Thanks for contributing to the project by https://github.com/g-truc/gli/issues[submitting issues] for bug reports and feature requests. Any feedback is welcome at gli@g-truc.net[mailto://gli@g-truc.net].

API
---

include::../doc/proto/is_compressed.txt[]

Code sample
-----------

--------------------------------------
#include <gli/gli.hpp>
GLuint CreateTextureArray(char const* Filename)
{
	gli::texture2DArray Texture(gli::load_dds(Filename));
	if(Texture.empty())
		return 0;

	gli::gl GL;
	gli::gl::format const Format = GL.translate(Texture.format());

	GLuint TextureName = 0;
	glGenTextures(1, &TextureName);
	glBindTexture(GL_TEXTURE_2D_ARRAY, TextureName);
	glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_BASE_LEVEL, 0);
	glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAX_LEVEL, static_cast<GLint>(Texture.levels() - 1));
	glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_SWIZZLE_R, Format.Swizzle[0]);
	glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_SWIZZLE_G, Format.Swizzle[1]);
	glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_SWIZZLE_B, Format.Swizzle[2]);
	glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_SWIZZLE_A, Format.Swizzle[3]);
	glTexStorage3D(GL_TEXTURE_2D_ARRAY, static_cast<GLint>(Texture.levels()), 
		Format.Internal,
		static_cast<GLsizei>(Texture.dimensions().x),
		static_cast<GLsizei>(Texture.dimensions().y),
		static_cast<GLsizei>(1));

	if(gli::is_compressed(Texture.format()))
	{
		for(std::size_t Level = 0; Level < Texture.levels(); ++Level)
		{
			glCompressedTexSubImage3D(GL_TEXTURE_2D_ARRAY, static_cast<GLint>(Level),
				0, 0, 0,
				static_cast<GLsizei>(Texture[Level].dimensions().x),
				static_cast<GLsizei>(Texture[Level].dimensions().y),
				static_cast<GLsizei>(1),
				Format.External,
				static_cast<GLsizei>(Texture[Level].size()),
				Texture[Level].data());
		}
	}
	else
	{
		for(std::size_t Level = 0; Level < Texture.levels(); ++Level)
		{
			glTexSubImage3D(GL_TEXTURE_2D_ARRAY, static_cast<GLint>(Level),
				0, 0, 0,
				static_cast<GLsizei>(Texture[Level].dimensions().x),
				static_cast<GLsizei>(Texture[Level].dimensions().y),
				static_cast<GLsizei>(1),
				Format.External, Format.Type,
				Texture[Level].data());
		}
	}
	return TextureName;
}
--------------------------------------
